package com.example.util;

import java.lang.invoke.MethodHandles;
import java.lang.invoke.VarHandle;
import java.lang.reflect.Array;
import java.lang.reflect.Field;
import java.util.*;
import java.util.concurrent.ConcurrentHashMap;

/**
 * Robust deep object graph sanitizer for primitive char fields.
 * Replaces '\u0000' with a space ' '.
 *
 * - Caches VarHandles per class for performance.
 * - Traverses nested objects, arrays, collections, and maps.
 * - Treats java.* types (including java.time.LocalDate) as leaves.
 * - Safely handles primitive and reference arrays.
 */
public final class CharFieldSanitizer {

    private static final Map<Class<?>, List<VarHandle>> CACHE = new ConcurrentHashMap<>();
    private static final char REPLACEMENT = ' ';

    private CharFieldSanitizer() {}

    public static void sanitize(Object root) {
        if (root == null) return;
        sanitizeObject(root, new IdentityHashMap<>());
    }

    private static void sanitizeObject(Object obj, IdentityHashMap<Object, Boolean> seen) {
        if (obj == null || seen.put(obj, Boolean.TRUE) != null) return;

        // If root is a Collection, Map or Array - handle directly (don't treat as POJO)
        if (obj instanceof Collection<?>) {
            for (Object e : (Collection<?>) obj) sanitizeObject(e, seen);
            return;
        }
        if (obj instanceof Map<?, ?>) {
            for (Object v : ((Map<?, ?>) obj).values()) sanitizeObject(v, seen);
            return;
        }

        Class<?> type = obj.getClass();
        if (type.isArray()) {
            // handle arrays (primitive and object arrays)
            Class<?> comp = type.getComponentType();
            if (comp == char.class) {
                char[] carr = (char[]) obj;
                for (int i = 0; i < carr.length; i++) {
                    if (carr[i] == '\u0000') carr[i] = REPLACEMENT;
                }
            } else if (!comp.isPrimitive()) {
                int len = Array.getLength(obj);
                for (int i = 0; i < len; i++) {
                    Object e = Array.get(obj, i);
                    sanitizeObject(e, seen);
                }
            }
            // primitive arrays other than char[] are ignored
            return;
        }

        // Treat JDK/platform types as leaves (including java.time.*) to avoid recursing into them
        if (isLeaf(type)) return;

        // 1) Sanitize char fields on this object using cached VarHandles
        for (VarHandle vh : handlesFor(type)) {
            try {
                char v = (char) vh.get(obj); // get() returns Object -> cast to char
                if (v == '\u0000') {
                    vh.set(obj, REPLACEMENT);
                }
            } catch (Throwable ignore) {
                // If anything goes wrong with this handle on this instance, skip it.
            }
        }

        // 2) Traverse declared fields (safe: catch access problems)
        for (Field f : type.getDeclaredFields()) {
            // skip synthetic / static fields
            if (f.isSynthetic() || java.lang.reflect.Modifier.isStatic(f.getModifiers())) continue;
            boolean accessible = f.canAccess(obj);
            try {
                f.setAccessible(true);
                Object val = f.get(obj);
                if (val == null) continue;

                Class<?> ft = f.getType();
                if (ft.isArray()) {
                    Class<?> comp = ft.getComponentType();
                    if (comp == char.class) {
                        char[] carr = (char[]) val;
                        for (int i = 0; i < carr.length; i++) {
                            if (carr[i] == '\u0000') carr[i] = REPLACEMENT;
                        }
                    } else if (!comp.isPrimitive()) {
                        int len = Array.getLength(val);
                        for (int i = 0; i < len; i++) {
                            Object e = Array.get(val, i);
                            sanitizeObject(e, seen);
                        }
                    }
                } else if (val instanceof Collection<?> col) {
                    for (Object e : col) sanitizeObject(e, seen);
                } else if (val instanceof Map<?, ?> map) {
                    for (Object v : map.values()) sanitizeObject(v, seen);
                } else if (!isLeaf(ft)) {
                    sanitizeObject(val, seen);
                }
            } catch (IllegalAccessException | IllegalArgumentException ex) {
                // Skip inaccessible or incompatible fields
            } finally {
                try {
                    if (!accessible) f.setAccessible(false);
                } catch (Throwable ignore) {}
            }
        }
    }

    private static List<VarHandle> handlesFor(Class<?> type) {
        return CACHE.computeIfAbsent(type, cls -> {
            List<VarHandle> list = new ArrayList<>();
            try {
                MethodHandles.Lookup lookup = MethodHandles.privateLookupIn(cls, MethodHandles.lookup());
                for (Field f : cls.getDeclaredFields()) {
                    if (f.getType() == char.class) {
                        try {
                            f.setAccessible(true);
                            VarHandle vh = lookup.unreflectVarHandle(f);
                            list.add(vh);
                        } catch (IllegalAccessException | SecurityException e) {
                            // skip fields we cannot access/unreflect
                        }
                    }
                }
            } catch (IllegalAccessException e) {
                // privateLookupIn might fail in modular setups; ignore and return empty list
            }
            return List.copyOf(list);
        });
    }

    private static boolean isLeaf(Class<?> t) {
        if (t.isPrimitive()) return true;
        if (t == String.class) return true;
        if (Number.class.isAssignableFrom(t)) return true;
        if (t == Character.class || t == Boolean.class) return true;
        if (t.isEnum()) return true;
        // treat all core JDK types as leaves (including java.time.*)
        String pkg = t.getPackage() == null ? "" : t.getPackage().getName();
        return pkg.startsWith("java.") || pkg.startsWith("javax.")
                || pkg.startsWith("jdk.") || pkg.startsWith("sun.");
    }
}
